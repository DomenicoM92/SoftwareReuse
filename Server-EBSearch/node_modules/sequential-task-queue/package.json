{
  "_from": "sequential-task-queue@^1.2.1",
  "_id": "sequential-task-queue@1.2.1",
  "_inBundle": false,
  "_integrity": "sha512-w2g0QgV37MSsI/qnvn8Z3NUGNilQA6p+NfujkSWI99rvBu/eTx3E0Z1rTIzaRxQj+gT9+Mta2azxyefnw0C25Q==",
  "_location": "/sequential-task-queue",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "sequential-task-queue",
    "fetchSpec": "^1.2.1",
    "name": "sequential-task-queue",
    "raw": "sequential-task-queue@^1.2.1",
    "rawSpec": "^1.2.1",
    "registry": true,
    "saveSpec": null,
    "type": "range"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/sequential-task-queue/-/sequential-task-queue-1.2.1.tgz",
  "_shasum": "eec0ef3c616c8f99b14eb6620ff7beef418984a4",
  "_spec": "sequential-task-queue@^1.2.1",
  "_where": "/home/dom/Desktop/SoftwareReuse/Server-EBSearch",
  "author": {
    "name": "BalassaMarton"
  },
  "bugs": {
    "url": "https://github.com/BalassaMarton/sequential-task-queue/issues"
  },
  "bundleDependencies": false,
  "dependencies": {},
  "deprecated": false,
  "description": "FIFO task queue for node and the browser",
  "devDependencies": {
    "@types/mocha": "^2.2.39",
    "@types/node": "^7.0.5",
    "@types/sinon": "^1.16.35",
    "del": "^2.2.2",
    "gulp": "^3.9.1",
    "gulp-mocha": "^3.0.1",
    "gulp-rename": "^1.2.2",
    "gulp-sourcemaps": "^2.4.1",
    "gulp-template": "^4.0.0",
    "gulp-typedoc": "^2.0.2",
    "gulp-typescript": "^3.1.5",
    "mocha": "^3.2.0",
    "run-sequence": "^1.2.2",
    "sinon": "^1.17.7",
    "snip-text": "^1.0.0",
    "typedoc": "^0.5.6",
    "typedoc-markdown-theme": "0.0.4",
    "typescript": "^2.1.6",
    "vinyl-paths": "^2.1.0"
  },
  "files": [
    "dist",
    "doc",
    "index.js"
  ],
  "homepage": "https://github.com/BalassaMarton/sequential-task-queue#readme",
  "name": "sequential-task-queue",
  "optionalDependencies": {},
  "readme": "# SequentialTaskQueue\r\n\r\n`SequentialTaskQueue` is a FIFO task queue for node and the browser. It supports promises, timeouts and task cancellation.\r\n\r\nThe primary goal of this component is to allow asynchronous tasks to be executed in a strict, predictable order. \r\nThis is especially useful when the application state is frequently mutated in response to asynchronous events.\r\n\r\n## Basic usage\r\n\r\nUse `push` to add tasks to the queue. The method returns a `Promise` that will fulfill when the task has been executed or cancelled.\r\n\r\n```js\r\nvar queue = new SequentialTaskQueue();\r\nqueue.push(() => {\r\n    console.log(\"first task\");\r\n});\r\nqueue.push(() => {\r\n    console.log(\"second task\");\r\n});\r\n```\r\n\r\n## Promises\r\n\r\nIf the function passed to `push` returns a `Promise`, the queue will wait for it to fulfill before moving to the next task.\r\nRejected promises don't cause the queue to stop executing tasks, but are reported in the `error` event (see below).  \r\n\r\n```js\r\nvar queue = new SequentialTaskQueue();\r\nqueue.push(() => {\r\n    console.log(\"1\");\r\n});\r\nqueue.push(() => {\r\n    return new Promise(resolve => {\r\n        setTimeout(() => {\r\n            console.log(\"2\");\r\n            resolve();\r\n        }, 500);\r\n    });\r\n});\r\nqueue.push(() => {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n            console.log(\"3\");\r\n            reject();\r\n        }, 100);\r\n    });\r\n});\r\nqueue.push(() => {\r\n    console.log(\"4\");\r\n});\r\n\r\n// Output:\r\n// 1\r\n// 2\r\n// 3\r\n// 4\r\n\r\n```\r\n\r\n## Task cancellation\r\n\r\nTasks waiting in the queue, as well as the currently executing task, can be cancelled. This is achieved by creating a `CancellationToken` object\r\nfor every task pushed to the queue, and passing it (to the task function) as the last argument. The task can then query the token's `cancelled` property to check if it\r\nhas been cancelled. The `Promise` returned by `push` is extended with a `cancel` method so that individual tasks can be cancelled.\r\n\r\n```js\r\nvar queue = new SequentialTaskQueue();\r\nvar task = queue.push(token => {\r\n    return new Promise((resolve, reject) => {\r\n        setTimeout(resolve, 100);\r\n    }).then(() => new Promise((resolve, reject) => {\r\n        if (token.cancelled)\r\n            reject();\r\n        else\r\n            resolve();\r\n    })).then(() => {\r\n        throw new Error(\"Should not ever get here\");\r\n    });\r\n});\r\nsetTimeout(() => {\r\n    task.cancel();\r\n}, 50);\r\n```\r\n\r\nIn the above example, the task is cancelled before the 100 ms timeout. \r\n\r\nWhen cancelling the current task, the queue will immediately schedule the next one, without waiting for the task to finish.\r\nIt is the task's responsibility to abort when the cancellation token is set, thus avoiding invalid application state.\r\nWhen a task is cancelled, the corresponding `Promise` is rejected with the cancellation reason, regardless of where the task currently is in the execution chain (running, scheduled or queued).\r\n\r\n## Timeouts\r\n\r\nTasks can be pushed into the queue with a timeout, after which the queue will cancel the task (the timer starts when the task is run, not when queued).\r\nThe timeout value is supplied to `push` in the second argument, which is interpreted as an options object for the task:\r\n\r\n```js\r\nvar queue = new SequentialTaskQueue();\r\n// ...\r\nfunction onEcho(query) {\r\n    queue.push(token => \r\n        backend.echo(query).then(response => {\r\n            if (!token.cancelled) {\r\n                state.addResponse(\"Server responded: \" + response);\r\n            }\r\n        }), { timeout: 1000 });\r\n}\r\n```\r\n\r\n## Passing arguments to the task\r\n\r\nIn most scenarios, you will be using the queue to respond to frequent, asynchronous events. Consider the following code that processes push notifications\r\ncoming from a server:\r\n\r\n```js\r\nbackend.on(\"notification\", (data) => {\r\n    queue.push(() => {\r\n        console.log(data);\r\n        // todo: do something with data\r\n    });\r\n});\r\n```\r\n \r\nEvery time the event handler is called, it creates a new function (and a closure), which can lead to poor performance. \r\nLet's rewrite this, now using the `args` property of the task options:\r\n\r\n```js\r\nbackend.on(\"notification\", (data) => {\r\n    queue.push(handleNotifiation, { args: data });\r\n});\r\n\r\nfunction handleNotifiation(data) {\r\n    console.log(data);\r\n    // todo: do something with data\r\n}\r\n```\r\n\r\nIf the `args` member of the options object is an array, the queue will pass the elements of the array as arguments, otherwise\r\nthe value is interpreted as the single argument to the task function. The cancellation token is always passed as the last argument.\r\nThe last bit also means that you can't simply push a function that has a rest (`...`) parameter, or uses the `arguments` object, \r\nsince the cancellation token would be appended.   \r\n\r\n## Waiting for all tasks to finish\r\n\r\nUse the `wait` method to obtain a `Promise` that fulfills when the queue is empty:\r\n  \r\n```js\r\nvar queue = new SequentialTaskQueue();\r\nqueue.push(task1);\r\nqueue.push(task2);\r\nqueue.push(task3);\r\nqueue.wait().then(() => { /*...*/ });\r\n```\r\n\r\n## Closing the queue\r\n\r\nAt certain points in your code, you may want to prevent adding more tasks to a queue (e.g. screen deactivation). \r\nThe `close` method closes the queue (sets the `isClosed` property to `true`), and returns a `Promise` that fulfills when the queue is empty. \r\nCalling `push` on a closed queue will throw an exception. Optionally, `close` can cancel all remaining tasks: \r\nto do so, pass a truthful value as its first parameter.\r\n\r\n```js\r\nvar queue = new SequentialTaskQueue();\r\n// ...\r\nfunction deactivate(done) {\r\n    queue.close(true).then(done);                \r\n} \r\n```\r\n\r\n## Handling errors\r\n\r\nErrors thrown inside a task are reported in the queue's `error` event (see below in the Events section). \r\nExceptions thrown in event handlers, however, are catched and ignored to avoid inifinite loops of error handling code.\r\n\r\n## Events\r\n\r\n`SequentialTaskQueue` implements the `on`, `removeListener` (`off`) and `once` methods of node's `EventEmitter` pattern. \r\n\r\nThe following events are defined:\r\n \r\n### error\r\n\r\nThe `error` event is emitted when a task throws an error or the `Promise` returned by the task is rejected. The error object is\r\npassed as the first argument of the event handler.\r\n\r\n### drained\r\n\r\nThe `drained` event is emitted when a task has finished executing, and the queue is empty. A cancelled queue will also emit this event.\r\n\r\n### timeout\r\n\r\nThe `timeout` event is emitted when a task is cancelled due to an expired timeout. The event is emitted before calling `cancel` on the task's cancellation token.  \r\n\r\n---\r\n## Changelog\r\n\r\n### 1.2.1\r\n\r\n`next` and `emit` are now protected instead of private.\r\n\r\n### 1.2.0\r\n\r\n`SequentialTaskQueue.push` now returns a `Promise`. Earlier versions only returned a cancellation token.\r\n\r\n---\r\nThis file was generated using [gulp-template](http://github.com/sindresorhus/gulp-template) and [snip-text](http://github.com/BalassaMarton/snip-text)",
  "readmeFilename": "readme.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/BalassaMarton/sequential-task-queue.git"
  },
  "types": "dist/types/sequential-task-queue.d.ts",
  "version": "1.2.1"
}
